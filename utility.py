import numpy as np

'''
This function returns the value of the D_ijk coefficient by putting the i, j, k in order
'''
def getDValue(i, j, k, D):

    # Put i, j, k in order
    if (i > j):
        midIndex = i
        lowIndex = j
    else:
        midIndex = j
        lowIndex = i

    if (midIndex > k):
        highIndex = midIndex
        if (lowIndex > k):
            midIndex = lowIndex
            lowIndex = k
        else:
            midIndex = k
    else:
        highIndex = k

    # Return the value of D
    return D[lowIndex, midIndex, highIndex];

'''
Given a set N1 of taken items, and the objective coefficients, compute the objective function value.
(assumes solution is feasible)
'''
def getObjVal(N1, c, C, D):
    N1 = list(N1)

    # compute overall contributions for lin, quad, and cubic separately
    linVal = 0
    quadVal = 0
    cubicVal = 0

    # compute contribution for each item in knapsack
    for i in range(len(N1)):
        # add linear contribution
        linVal += c[N1[i]]

        for j in range(i+1, len(N1)):
            # add up quadratic contributions
            quadVal += C[N1[i],N1[j]] + C[N1[j],N1[i]]

            for k in range(j+1, len(N1)):
                # add up cubic contributions
                cubicVal += getDValue(N1[i],N1[j],N1[k],D)

    # print(f"lin val is {linVal}")
    # print(f"quad val is {quadVal}")
    # print(f"cubic val is {cubicVal}")

    return linVal+quadVal+cubicVal


'''
Given a feasible solution (perhaps generated by the naive or advaned greedy heuristics),
perform single element swaps until no more improving swaps can be made
'''
def perform_swaps(N1, cubic, N0=None, initRHS=None):
    n = cubic.n
    c = cubic.c
    C = cubic.C
    D = cubic.D
    a = cubic.a
    b = cubic.b

    # helpful to have N1 as a list rather than a set
    N1 = list(N1)

    # create N0 as the set of variables not in N1 (N - N1)
    # N0 may be provided (e.g. if doing swaps for a multiple knapsack hover oscillation)
    if N0 is None:
        N0 = set()
        for i in range(n):
            if i not in N1:
                N0.add(i)

    # store individual contribution of each item
    contributions = np.zeros(n)

    # compute initial objective contributions for each item (taken or not)
    # for vars in N0 this would be the contribution if it were taken right now without removing anything
    for i in range(n):
        # check if item can possibly be swapped
        if i not in N0 and i not in N1:
            # this occurs if in multiple knapsack and item is already in another knapsack
            contributions[i] = -1
            continue

        # add linear contribution
        contributions[i] += c[i]

        # add pairwise contributions with each item already taken
        for j in range(len(N1)):
            if N1[j] > i:
                contributions[i] += C[i,N1[j]]
            elif N1[j] < i:
                contributions[i] += C[N1[j],i]

            # add triplet contributions with each pair already taken
            for k in range(j+1,len(N1)):
                contributions[i] += getDValue(i,N1[j],N1[k],D)


    # compute initial RHS (remaining capacity in knapsack) if needed
    # RHS is the amount of space remaining in knapsack
    if initRHS is None:
        RHS = b
        for item in N1:
            RHS = RHS - a[item][0]
    else:
        RHS = initRHS

    # print(f"init RHS: {RHS}")
    # print(f"total knapsack capacity: {b}")
    # print(f"item weights (a) = {a}")

    improve = True

    while improve:

        # keep track of best possible improvment so far

        # best pair improvement
        delta_pq = 0
        best_pair = (-1,-1)

        # go through each x_i,x_0 pair and compute obj change of potential swap
        for taken in N1:
            for untaken in N0:
                # determine if this pair is feasible
                # (check if still feasible after swap)
                if RHS + a[taken][0] - a[untaken][0] < 0:
                    # making this pair swap is not feasbile, go to the next one
                    break

                # compute obj change associated with this pair
                delta_ij = contributions[untaken] - contributions[taken]

                # remove invalid quadratic value
                if taken > untaken:
                    delta_ij -= C[untaken,taken]
                else:
                    delta_ij -= C[taken,untaken]

                # remove invalid cubic values
                for k in N1:
                    if (k == taken): continue
                    delta_ij -= getDValue(taken, untaken, k, D)

                # update best value
                if delta_ij > delta_pq:
                    delta_pq = delta_ij
                    best_pair = (taken, untaken)

        # now check if any items can be added for free (without a swap)
        single_delta = 0 # best single elem improvement
        best_single = -1 # best item to take
        for item in N0:
            # check if item can fit (without making any swaps). If not, continue
            if RHS < a[item][0]: continue

            # if item is worthless, continue to next item
            if contributions[item] <= 0: continue

            # objChange is simply the contribution of this item
            # if this is best so far, update
            if contributions[item] > single_delta:
                single_delta = contributions[item]
                best_single = item

        # if we can improve, maybe the relevant updates
        if delta_pq > 0 or single_delta > 0:
            # make a swap
            if delta_pq > single_delta:
                old_item = best_pair[0]
                new_item = best_pair[1]

                # remove item that was taken
                N1.remove(old_item)
                N0.add(new_item)

                # put in new item
                N0.remove(new_item)
                N1.append(new_item)

                # update contributions for all items
                for i in range(n):
                    if i < old_item:
                        contributions[i] -= C[i,old_item]
                    else:
                        contributions[i] -= C[old_item,i]

                    if i < new_item:
                        contributions[i] += C[i,new_item]
                    else:
                        contributions[i] += C[new_item,i]

                    for k in range(n):
                        contributions[i] += getDValue(i,k,new_item,D)
                        contributions[i] -= getDValue(i,k,new_item,D)


                # update RHS
                RHS += a[old_item][0] # increase capacity by weight of item revomed
                RHS -= a[new_item][0] # decrease capacity by weight of item added

                print(f"Best change is {delta_pq}. Produced by swapping {best_pair}")
                print(f"The change in capacity remaining is {a[new_item][0] - a[old_item][0]}")
                print(f"The new remaining capacity is {RHS}")

            else:
                # add single item
                N0.remove(best_single)
                N1.append(best_single)

                # update contributions for all items
                for i in range(n):
                    if i < best_single:
                        contributions[i] += C[i,best_single]
                    else:
                        contributions[i] += C[best_single,i]

                    for k in range(n):
                        contributions[i] += getDValue(i,k,best_single,D)

                # update RHS
                RHS -= a[best_single][0]

                print(f"Best change is {single_delta}. Produced by adding {best_single}")
                print(f"The change in capacity remaining is {a[new_item][0] - a[old_item][0]}")
                print(f"The new remaining capacity is {RHS}")
        else:
            # no more improvement to be made so exit swapping
            improve = False

    # return improved solution
    return N1
